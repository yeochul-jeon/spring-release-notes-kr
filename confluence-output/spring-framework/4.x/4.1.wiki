h1. Spring Framework 4.1 릴리즈 노트

h2. 1. 개요

Spring Framework 4.1은 *2014년 9월*에 출시되었습니다. 어노테이션 기반 JMS 리스너({{@JmsListener}}), JCache(JSR-107) 캐시 표준 지원, SpEL 컴파일러를 통한 표현식 성능 향상, 그리고 정적 리소스 처리 파이프라인 개선 등이 핵심 변경사항입니다. 4.0에서 4.1로의 마이그레이션은 비교적 수월하며, 대부분의 기존 코드가 그대로 동작합니다.

----

h2. 2. 주요 변경사항

h3. 2.1 @JmsListener - 어노테이션 기반 JMS 메시지 리스너

기존에는 JMS 메시지를 수신하려면 XML 설정에서 {{MessageListenerContainer}}를 등록해야 했습니다. 4.1부터는 {{@JmsListener}} 어노테이션만 붙이면 간단하게 메시지 리스너를 구성할 수 있습니다.

{code:language=java|theme=Emacs}
@Configuration
@EnableJms  // JMS 리스너 자동 감지 활성화
public class JmsConfig {
    @Bean
    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory(
            ConnectionFactory connectionFactory) {
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory);
        factory.setConcurrency("3-10"); // 최소 3개, 최대 10개 스레드
        return factory;
    }
}
{code}

{code:language=java|theme=Emacs}
@Component
public class OrderListener {
    // "order.queue" 큐에서 메시지를 수신합니다
    @JmsListener(destination = "order.queue")
    public void processOrder(Order order) {
        System.out.println("주문 수신: " + order.getId());
    }

    // selector로 특정 조건의 메시지만 필터링, @SendTo로 결과를 다른 큐에 전송
    @JmsListener(destination = "order.queue", selector = "type = 'priority'")
    @SendTo("order.confirmation.queue")
    public Confirmation processPriority(Order order) {
        return new Confirmation(order.getId(), "PROCESSED");
    }
}
{code}

{quote}
*초보자 팁:* {{@JmsListener}}는 Spring MVC의 {{@RequestMapping}}과 비슷한 개념입니다. HTTP 요청 대신 *메시지 큐의 메시지*를 받아 처리하는 메서드를 지정하는 것입니다.
{quote}

h3. 2.2 JCache (JSR-107) 캐시 어노테이션 지원

JSR-107은 자바 표준 캐시 API입니다. 4.1부터 Spring 고유의 {{@Cacheable}} 외에 *JCache 표준 어노테이션*도 함께 사용할 수 있습니다.

|| Spring 어노테이션 || JCache 표준 어노테이션 || 설명 ||
| {{@Cacheable}} | {{@CacheResult}} | 결과를 캐시에 저장 |
| {{@CacheEvict}} | {{@CacheRemove}} | 특정 캐시 항목 제거 |
| {{@CacheEvict(allEntries=true)}} | {{@CacheRemoveAll}} | 캐시 전체 제거 |
| - | {{@CacheDefaults}} | 클래스 레벨 기본 캐시 설정 |

{code:language=java|theme=Emacs}
import javax.cache.annotation.CacheResult;
import javax.cache.annotation.CacheRemove;

@Service
public class ProductService {
    @CacheResult(cacheName = "products")  // 결과를 캐시에 저장
    public Product findById(Long id) {
        return productRepository.findById(id); // 캐시 히트 시 실행되지 않음
    }

    @CacheRemove(cacheName = "products")  // 해당 캐시 항목 제거
    public void deleteProduct(Long id) {
        productRepository.deleteById(id);
    }
}
{code}

h3. 2.3 SpEL 컴파일러

SpEL(Spring Expression Language) 표현식을 *JIT(Just-In-Time) 컴파일*하여 성능을 크게 향상시킵니다. 반복적으로 평가되는 표현식에 특히 유용합니다.

컴파일 모드는 3가지입니다:

|| 모드 || 설명 ||
| {{OFF}} | 컴파일 비활성화 (기본값) |
| {{IMMEDIATE}} | 첫 평가 시 즉시 컴파일 |
| {{MIXED}} | 여러 번 평가 후 안정적이면 컴파일 (권장) |

{code:language=java|theme=Emacs}
// SpEL 컴파일러를 MIXED 모드로 활성화
SpelParserConfiguration config =
        new SpelParserConfiguration(SpelCompilerMode.MIXED, null);
SpelExpressionParser parser = new SpelExpressionParser(config);

// 이 표현식은 반복 호출 시 바이트코드로 컴파일되어 빠르게 실행됩니다
Expression expr = parser.parseExpression("name.toUpperCase()");
{code}

또는 시스템 프로퍼티로 전역 설정할 수 있습니다:

{code:language=properties|theme=Emacs}
spring.expression.compiler.mode=MIXED
{code}

h3. 2.4 정적 리소스 처리 개선

정적 리소스(CSS, JS, 이미지 등)를 처리하는 *ResourceResolver / ResourceTransformer 체인* 구조가 도입되었습니다. 이를 통해 버전 관리, 압축, 캐싱 등을 유연하게 구성할 수 있습니다.

{code:language=java|theme=Emacs}
@Configuration
@EnableWebMvc
public class WebConfig extends WebMvcConfigurerAdapter {

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")
                .addResourceLocations("classpath:/static/")
                .resourceChain(true)  // 캐싱 활성화
                // 파일 내용 기반 해시를 URL에 추가 (캐시 무효화용)
                .addResolver(new VersionResourceResolver()
                        .addContentVersionStrategy("/**"))
                // Gzip 압축 파일이 있으면 자동으로 제공
                .addResolver(new GzipResourceResolver());
    }
}
{code}

{quote}
*초보자 팁:* {{VersionResourceResolver}}는 파일이 변경되면 URL도 바뀌게 만들어, 브라우저가 오래된 캐시를 사용하는 문제를 방지합니다. 예를 들어 {{style.css}}가 {{style\-abc123.css}}처럼 제공됩니다.
{quote}

----

h2. 3. 새로운 기능

h3. 3.1 Jackson @JsonView 통합

컨트롤러 메서드에서 {{@JsonView}}를 사용하여 *같은 객체를 상황에 따라 다르게 직렬화*할 수 있습니다.

{code:language=java|theme=Emacs}
// 뷰(View) 인터페이스 정의
public class Views {
    public interface Summary {}      // 요약 정보
    public interface Detail extends Summary {}  // 상세 정보 (요약 포함)
}

public class User {
    @JsonView(Views.Summary.class)
    private String name;

    @JsonView(Views.Detail.class)
    private String email;  // 상세 뷰에서만 노출
}

@RestController
public class UserController {

    // 목록 조회 시 요약 정보만 반환
    @JsonView(Views.Summary.class)
    @GetMapping("/users")
    public List<User> listUsers() { ... }

    // 단건 조회 시 상세 정보 반환
    @JsonView(Views.Detail.class)
    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) { ... }
}
{code}

h3. 3.2 ResponseEntity Builder API

{{ResponseEntity}}를 빌더 패턴으로 더 깔끔하게 생성할 수 있습니다.

{code:language=java|theme=Emacs}
@GetMapping("/users/{id}")
public ResponseEntity<User> getUser(@PathVariable Long id) {
    User user = userService.findById(id);
    if (user == null) {
        return ResponseEntity.notFound().build(); // 404
    }
    // 200 OK + ETag + 캐시 설정 + 바디
    return ResponseEntity.ok()
            .eTag(user.getVersion().toString())
            .cacheControl(CacheControl.maxAge(30, TimeUnit.MINUTES))
            .body(user);
}

@PostMapping("/users")
public ResponseEntity<Void> createUser(@RequestBody User user) {
    User saved = userService.save(user);
    URI location = URI.create("/users/" + saved.getId());
    return ResponseEntity.created(location).build(); // 201 Created + Location
}
{code}

h3. 3.3 java.util.Optional 지원

Java 8의 {{Optional}}을 의존성 주입(DI)과 MVC에서 사용할 수 있습니다.

{code:language=java|theme=Emacs}
@RestController
public class SearchController {
    // 필수가 아닌 요청 파라미터를 Optional로 받을 수 있습니다
    @GetMapping("/search")
    public List<Product> search(
            @RequestParam Optional<String> keyword,
            @RequestParam Optional<Integer> page) {
        String searchKeyword = keyword.orElse("");    // 없으면 빈 문자열
        int pageNumber = page.orElse(0);              // 없으면 0페이지
        return productService.search(searchKeyword, pageNumber);
    }
}
{code}

{code:language=java|theme=Emacs}
@Service
public class NotificationService {
    // 해당 빈이 없어도 에러 없이 주입됩니다 (Optional.empty())
    private final Optional<SmsService> smsService;

    public NotificationService(Optional<SmsService> smsService) {
        this.smsService = smsService;
    }
}
{code}

h3. 3.4 Protocol Buffers HTTP 메시지 컨버터

Google의 직렬화 포맷인 *Protocol Buffers(Protobuf)*를 Spring MVC에서 바로 사용할 수 있는 {{ProtobufHttpMessageConverter}}가 추가되었습니다. JSON보다 더 작고 빠른 데이터 전송이 필요한 경우에 유용합니다.

h3. 3.5 @Sql / @SqlConfig - 선언적 테스트 SQL 실행

테스트에서 SQL 스크립트를 어노테이션으로 간편하게 실행할 수 있습니다.

{code:language=java|theme=Emacs}
@SpringJUnit4ClassRunner.class
@ContextConfiguration
@Sql("/test-data.sql")  // 테스트 실행 전 SQL 스크립트를 자동 실행
public class UserRepositoryTest {
    @Test
    @Sql(
        scripts = "/clean-up.sql",
        executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD,  // 테스트 후 실행
        config = @SqlConfig(encoding = "UTF-8", separator = ";;")
    )
    public void testFindAll() {
        // test-data.sql로 준비된 데이터를 이용한 테스트
    }
}
{code}

----

h2. 4. 개선사항

* *Groovy 기반 Bean 정의 개선:* Groovy DSL을 통한 Bean 설정이 더 유연해졌습니다.
* *메시지 변환기 자동 감지:* 클래스패스에 Jackson, JAXB 등이 있으면 자동으로 메시지 컨버터가 등록됩니다.
* *MVC 뷰 리졸버 개선:* 콘텐츠 협상(Content Negotiation) 기반의 뷰 리졸버가 개선되었습니다.
* *WebSocket STOMP 개선:* STOMP 프로토콜 지원이 안정화되고 성능이 향상되었습니다.
* *테스트 프레임워크:* \{\{TestContext\}\} 프레임워크에서 조건부 테스트 실행, SQL 스크립트 실행 등이 추가되었습니다.

----

h2. 5. 폐기(Deprecated) 및 제거(Removed) 항목

h3. 제거된 항목

|| 항목 || 설명 ||
| *Quartz 1.8 지원* | Quartz Scheduler 1.8 버전 지원이 제거되었습니다. Quartz 2.x를 사용해야 합니다. |
| *Jackson v1 클래스* | {{org.codehaus.jackson}} 기반 클래스가 제거되었습니다. {{com.fasterxml.jackson}}(Jackson 2.x)을 사용해야 합니다. |

{quote}
*초보자 팁:* Jackson v1({{org.codehaus.jackson}})과 Jackson v2({{com.fasterxml.jackson}})는 패키지명이 다릅니다. import문을 확인하여 v2를 사용하고 있는지 점검하세요.
{quote}

----

h2. 6. 호환성

|| 항목 || 요구 사항 ||
| *Java 버전* | Java 6 이상 (Java 8 권장) |
| *Servlet 버전* | Servlet 2.5 이상 (Servlet 3.0+ 권장) |
| *Jackson* | Jackson 2.x 필수 (v1 지원 제거) |
| *Quartz* | Quartz 2.x 필수 (1.8 지원 제거) |
| *JCache* | JSR-107 API 1.0 |

4.0에서 4.1로의 업그레이드 시 주요 확인 사항:

* Jackson v1 사용 중이라면 v2로 마이그레이션 필요
* Quartz 1.8 사용 중이라면 2.x로 업그레이드 필요
* 그 외에는 대부분 하위 호환되므로 원활한 전환 가능

----

h2. 7. 참고 자료

* [Spring Framework 4.1 Release Notes (GitHub Wiki)|https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-4.x#spring-framework-41]
* [Spring Blog - Spring Framework 4.1 GA|https://spring.io/blog/2014/09/04/spring-framework-4-1-ga-is-here]
* [Spring Framework 4.1 Reference Documentation|https://docs.spring.io/spring-framework/docs/4.1.x/spring-framework-reference/]
* [Spring Framework 4.0 릴리즈 노트|./4.0.md]
