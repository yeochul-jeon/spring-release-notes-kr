h1. Spring Framework 4.3 릴리즈 노트

Spring Framework 4.3은 2016년 6월에 릴리즈된 *4.x 시리즈의 마지막 버전*입니다. 생성자가 하나인 경우 {{@Autowired}}를 생략할 수 있는 암묵적 생성자 주입, {{@GetMapping}}/{{@PostMapping}} 등 합성(Composed) 어노테이션, 그리고 {{ObjectProvider}}를 통한 유연한 의존성 해결이 핵심입니다. OSS 지원은 2020년 12월에 종료되었습니다.

----

h2. 주요 변경사항

h3. 기준선(Baseline) 요구사항

Spring Framework 4.3이 요구하는 최소 환경입니다. 4.x 시리즈의 마지막 세대로서 Java 6+, Servlet 2.5+ 기준선을 유지합니다.

|| 항목 || 요구사항 ||
| *Java* | 6+ (Java 8 권장) |
| *Servlet* | 2.5+ (Servlet 3.0+ 권장) |
| *JPA* | 2.0+ |
| *Hibernate* | 3.6+ (5.x 권장) |
| *Jackson* | 2.6+ |

{quote}
*초보자 안내:* 기준선(Baseline)이란 "최소한 이 버전 이상이어야 동작한다"는 의미입니다. 4.3은 Java 6에서도 동작하지만, 실무에서는 Java 8 이상을 사용하는 것이 좋습니다.
{quote}

h3. 암묵적 생성자 주입 (Implicit Constructor Injection)

Spring 4.3의 가장 대표적인 변경사항입니다. *생성자가 하나만 있는 빈(Bean)은 {{@Autowired}}를 붙이지 않아도 자동으로 의존성이 주입*됩니다.

{code:language=java|theme=Emacs}
// Spring 4.2 이전: @Autowired가 반드시 필요
@Service
public class UserService {

    private final UserRepository repository;

    @Autowired  // 이 어노테이션이 없으면 주입이 안 됨
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
}

// Spring 4.3: 생성자가 하나면 @Autowired 생략 가능
@Service
public class UserService {

    private final UserRepository repository;

    // @Autowired 없이도 자동 주입됨
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
}
{code}

{quote}
*왜 중요한가요?* 이 기능 덕분에 Lombok의 {{@RequiredArgsConstructor}}와 조합하면 보일러플레이트 코드를 크게 줄일 수 있습니다. 현재 Spring 생태계에서 가장 널리 쓰이는 의존성 주입 패턴의 기반이 되었습니다.
{quote}

{code:language=java|theme=Emacs}
// Lombok과 조합한 최종 형태 (가장 권장되는 패턴)
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository repository;
    // 생성자가 자동 생성되고, @Autowired 없이도 주입됨
}
{code}

h3. 합성 @RequestMapping 어노테이션 (Composed Annotations)

HTTP 메서드별로 축약된 어노테이션이 도입되었습니다. {{@RequestMapping(method = RequestMethod.GET)}} 대신 {{@GetMapping}}처럼 간결하게 작성할 수 있습니다.

|| 새 어노테이션 || 대체하는 기존 코드 ||
| {{@GetMapping}} | {{@RequestMapping(method = RequestMethod.GET)}} |
| {{@PostMapping}} | {{@RequestMapping(method = RequestMethod.POST)}} |
| {{@PutMapping}} | {{@RequestMapping(method = RequestMethod.PUT)}} |
| {{@DeleteMapping}} | {{@RequestMapping(method = RequestMethod.DELETE)}} |
| {{@PatchMapping}} | {{@RequestMapping(method = RequestMethod.PATCH)}} |

{code:language=java|theme=Emacs}
// Spring 4.2 이전: method 속성을 매번 지정
@RestController
@RequestMapping("/users")
public class UserController {

    @RequestMapping(method = RequestMethod.GET)
    public List<User> getUsers() { ... }

    @RequestMapping(method = RequestMethod.POST)
    public User createUser(@RequestBody User user) { ... }

    @RequestMapping(value = "/{id}", method = RequestMethod.PUT)
    public User updateUser(@PathVariable Long id, @RequestBody User user) { ... }

    @RequestMapping(value = "/{id}", method = RequestMethod.DELETE)
    public void deleteUser(@PathVariable Long id) { ... }
}

// Spring 4.3: 합성 어노테이션으로 간결하게
@RestController
@RequestMapping("/users")
public class UserController {

    @GetMapping
    public List<User> getUsers() { ... }

    @PostMapping
    public User createUser(@RequestBody User user) { ... }

    @PutMapping("/{id}")
    public User updateUser(@PathVariable Long id, @RequestBody User user) { ... }

    @DeleteMapping("/{id}")
    public void deleteUser(@PathVariable Long id) { ... }
}
{code}

{quote}
*초보자 안내:* 이 합성 어노테이션은 현재 Spring MVC/WebFlux에서 *사실상 표준*으로 사용되고 있습니다. 기존 {{@RequestMapping(method = ...)}}을 사용해도 동작하지만, 새 코드에서는 합성 어노테이션을 사용하는 것이 권장됩니다.
{quote}

h3. ObjectProvider를 통한 유연한 의존성 해결

{{ObjectProvider<T>}}는 특정 빈이 존재하지 않을 수도 있는 상황에서 *안전하게 의존성을 해결*할 수 있는 인터페이스입니다.

{code:language=java|theme=Emacs}
@Service
public class NotificationService {

    private final ObjectProvider<EmailService> emailProvider;

    // 생성자 하나이므로 @Autowired 생략 가능 (위의 암묵적 생성자 주입)
    public NotificationService(ObjectProvider<EmailService> emailProvider) {
        this.emailProvider = emailProvider;
    }

    public void notify(String message) {
        // EmailService 빈이 존재할 때만 실행
        emailProvider.ifAvailable(svc -> svc.send(message));
    }

    public EmailService getEmailOrDefault() {
        // EmailService 빈이 없으면 기본 구현 반환
        return emailProvider.getIfAvailable(DefaultEmailService::new);
    }
}
{code}

{quote}
*언제 쓰나요?* 선택적(Optional) 의존성이 필요할 때 유용합니다. 예를 들어 특정 모듈이 설치되어 있을 때만 동작하는 기능을 구현할 때 {{ObjectProvider}}를 사용하면 빈이 없어도 애플리케이션이 정상 시작됩니다.
{quote}

h3. InjectionPoint - 주입 지점 메타데이터 접근

{{@Bean}} 메서드에서 *어디에 주입되는지*에 대한 정보를 알 수 있는 {{InjectionPoint}} 파라미터가 도입되었습니다. 주로 로거(Logger) 팩토리 빈을 만들 때 활용됩니다.

{code:language=java|theme=Emacs}
@Configuration
public class LoggerConfig {

    @Bean
    @Scope("prototype")  // 주입받는 곳마다 새 인스턴스 생성
    public Logger logger(InjectionPoint injectionPoint) {
        // 주입되는 클래스 이름으로 로거 생성
        return LoggerFactory.getLogger(
            injectionPoint.getMethodParameter().getContainingClass()
        );
    }
}

// 사용하는 곳
@Service
public class OrderService {
    private final Logger log;  // OrderService용 로거가 자동 생성됨

    public OrderService(Logger log) {
        this.log = log;
    }
}
{code}

----

h2. 새로운 기능

* *암묵적 생성자 주입*: 단일 생성자 빈에서 \{\{@Autowired\}\} 생략 가능 (위 상세 설명 참고)
* *합성 @RequestMapping 어노테이션*: \{\{@GetMapping\}\}, \{\{@PostMapping\}\}, \{\{@PutMapping\}\}, \{\{@DeleteMapping\}\}, \{\{@PatchMapping\}\} 도입
* *ObjectProvider*: 선택적 의존성 및 지연(Lazy) 해결을 위한 프로그래밍 방식 API
* *InjectionPoint*: \{\{@Bean\}\} 메서드에서 주입 대상의 메타데이터 접근
* *HEAD/OPTIONS 기본 처리*: Spring MVC에서 HEAD와 OPTIONS HTTP 메서드를 자동 처리
* *캐시 SpEL 개선*: \{\{@Cacheable\}\} 등 캐시 어노테이션에서 \{\{@beanName.method()\}\} 형태의 SpEL 표현식 지원
* *@Scheduled 개선*: 더 유연한 스케줄링 구성 및 합성(Composed) 어노테이션 지원

----

h2. 개선사항

|| 영역 || 개선 내용 ||
| *Spring MVC* | HEAD/OPTIONS 요청에 대한 기본 핸들링 추가 |
| *캐싱* | SpEL 표현식에서 빈 메서드 호출({{@beanName.method()}}) 지원 |
| *의존성 주입* | {{ObjectProvider}} 스트리밍 API 및 정렬 지원 |
| *스케줄링* | {{@Scheduled}} 어노테이션의 합성(Composed) 사용 가능 |
| *테스트* | JUnit 4.12+ 지원 강화 및 규칙(Rule) 통합 |
| *CORS* | {{@CrossOrigin}} 어노테이션의 세밀한 설정 옵션 추가 |

----

h2. 폐기(Deprecated) 및 제거(Removed) 항목

h3. 폐기 예고 (Deprecated)

Spring 4.3은 4.x의 마지막 버전으로서, Spring 5.0에서 제거될 항목들을 사전 폐기 처리했습니다.

|| 항목 || 대안 || 비고 ||
| {{JdbcTemplate}}의 {{queryForObject}} (여러 오버로드) | 표준화된 메서드 시그니처 사용 | 5.0에서 정리 |
| 일부 {{PropertyEditor}} 관련 API | {{ConversionService}} 사용 | 5.0에서 정리 |
| Velocity 템플릿 지원 | FreeMarker 또는 Thymeleaf 사용 | Apache Velocity 프로젝트 중단에 따른 조치 |
| Guava 캐시 지원 | Caffeine 캐시로 전환 | Guava Cache가 Caffeine으로 대체됨 |
| XMLBeans, JiBX 바인딩 | JAXB 또는 Jackson XML 사용 | 5.0에서 제거 |

{quote}
*마이그레이션 참고:* 4.3에서 deprecated 된 항목은 대부분 Spring 5.0에서 완전히 제거되었습니다. 4.3을 사용 중이라면 deprecated 경고를 주의 깊게 확인하고, 5.0으로의 마이그레이션을 준비하는 것이 좋습니다.
{quote}

----

h2. 호환성

{code:language=text|title=mermaid|collapse=true|theme=Emacs}
graph TD
    SF43[Spring Framework 4.3] --> JDK[Java 6+]
    SF43 --> SV[Servlet 2.5+]
    SF43 --> SB1[Spring Boot 1.4 / 1.5]

    SV --> TC7[Tomcat 7+]
    SV --> TC8[Tomcat 8+]
    SV --> JT9[Jetty 9+]

    SF43 --> JPA20[JPA 2.0+]
    JPA20 --> HB36[Hibernate 3.6+]
    JPA20 --> HB5[Hibernate 5.x 권장]

    SF43 --> JK26[Jackson 2.6+]
{code}

h3. Spring 포트폴리오 호환

* *Spring Boot 1.4 / 1.5* - Spring Framework 4.3 기반
* *Spring Security 4.1 / 4.2*
* *Spring Data Hopper / Ingalls*

h3. 지원 기간

|| 구분 || 기간 ||
| *OSS 지원* | 2016년 6월 ~ 2020년 12월 (종료) |
| *상업 지원* | 2020년 12월 이후 VMware 상업 지원으로 전환 |

{quote}
*강력 권고:* Spring Framework 4.3은 이미 OSS 지원이 종료되었습니다. 보안 패치를 받으려면 [Spring Framework 6.x|../6.x/6.0.md] 이상으로 마이그레이션하는 것을 강력히 권장합니다.
{quote}

----

h2. 참고 자료

* [Spring Framework 4.3 Release Notes (GitHub Wiki)|https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-4.3-Release-Notes]
* [What's New in Spring Framework 4.x (GitHub Wiki)|https://github.com/spring-projects/spring-framework/wiki/What's-New-in-Spring-Framework-4.x]
* [Spring Blog - Spring Framework 4.3 goes GA|https://spring.io/blog/2016/06/10/spring-framework-4-3-goes-ga]
* [Upgrading to Spring Framework 5.x (GitHub Wiki)|https://github.com/spring-projects/spring-framework/wiki/Upgrading-to-Spring-Framework-5.x]
