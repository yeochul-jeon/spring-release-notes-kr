h1. Spring Framework 5.2 릴리즈 노트

Spring Framework 5.2는 2019년 9월에 출시되었으며, 마이크로서비스 간 통신을 위한 *RSocket 지원*, Kotlin *코루틴(Coroutines)* 통합, {{@Configuration}} *라이트 모드*, 그리고 서블릿 기반의 *함수형 엔드포인트(WebMvc.fn)* 등 다양한 신기능을 도입했습니다. Spring Boot 2.2가 이 버전을 기반으로 합니다.

----

h2. 주요 변경사항

h3. 1. RSocket 지원

RSocket은 리액티브 스트림(Reactive Streams) 기반의 *바이너리 프로토콜*입니다. HTTP와 달리 요청-응답뿐만 아니라, Fire-and-Forget(보내고 잊기), 스트리밍 등 다양한 통신 패턴을 지원합니다. 마이크로서비스 간 효율적인 통신에 적합합니다.

*서버 측 - {{@MessageMapping}} 사용*

{{@MessageMapping}}은 RSocket 메시지를 처리하는 핸들러 메서드를 지정하는 어노테이션입니다. HTTP의 {{@RequestMapping}}과 유사한 역할을 합니다.

{code:language=java|theme=Emacs}
@Controller
public class MarketDataController {

    private final MarketDataService marketDataService;

    // 생성자 주입 (권장 방식)
    public MarketDataController(MarketDataService marketDataService) {
        this.marketDataService = marketDataService;
    }

    // "currentMarketData"라는 경로(route)로 들어오는 RSocket 메시지를 처리
    @MessageMapping("currentMarketData")
    public Mono<MarketData> currentMarketData(MarketDataRequest request) {
        return marketDataService.getMarketData(request.getStock());
    }

    // 스트리밍 방식: 실시간으로 시세 데이터를 지속적으로 전송
    @MessageMapping("feedMarketData")
    public Flux<MarketData> feedMarketData(MarketDataRequest request) {
        return marketDataService.getMarketDataStream(request.getStock());
    }
}
{code}

*클라이언트 측 - {{RSocketRequester}} 사용*

{{RSocketRequester}}는 RSocket 서버에 요청을 보내기 위한 클라이언트 객체입니다.

{code:language=java|theme=Emacs}
@Service
public class MarketDataClient {

    private final RSocketRequester requester;

    public MarketDataClient(RSocketRequester.Builder builder) {
        // 서버에 연결하는 RSocketRequester 생성
        this.requester = builder.connectTcp("localhost", 7000).block();
    }

    public Mono<MarketData> getCurrentData(String stock) {
        return requester
            .route("currentMarketData")              // 서버의 @MessageMapping 경로 지정
            .data(new MarketDataRequest(stock))       // 요청 데이터 설정
            .retrieveMono(MarketData.class);          // 단일 응답 수신
    }
}
{code}

----

h3. 2. Kotlin 코루틴(Coroutines) 지원

Kotlin 코루틴은 비동기 프로그래밍을 *동기 코드처럼* 작성할 수 있게 해주는 기능입니다. 기존에는 {{Mono}}나 {{Flux}}를 직접 다뤄야 했지만, 코루틴을 사용하면 {{suspend}} 키워드만으로 비동기 처리가 가능합니다.

*기존 방식 (Mono/Flux 직접 사용)*

{code:language=kotlin|theme=Emacs}
@GetMapping("/users/{id}")
fun getUser(@PathVariable id: Long): Mono<User> {
    return userService.findById(id)  // Mono를 직접 반환해야 함
}
{code}

*코루틴 방식 (5.2부터 지원)*

{code:language=kotlin|theme=Emacs}
// suspend 키워드를 붙이면 비동기 함수가 됨
// Mono 대신 일반 객체를 반환할 수 있어 코드가 훨씬 간결
@GetMapping("/users/{id}")
suspend fun getUser(@PathVariable id: Long): User {
    return userService.findById(id)
}

// Flux 대신 Flow를 사용하여 스트리밍 데이터 반환
@GetMapping("/users", produces = [MediaType.TEXT_EVENT_STREAM_VALUE])
fun getAllUsers(): Flow<User> {
    return userService.findAll()
}
{code}

{quote}
*참고:* 코루틴을 사용하려면 프로젝트에 {{kotlinx\-coroutines\-reactor}} 의존성을 추가해야 합니다.
{quote}

----

h3. 3. {{@Configuration}} 라이트 모드

기존 {{@Configuration}} 클래스는 CGLIB 프록시를 사용하여 {{@Bean}} 메서드 간 호출 시 싱글톤을 보장했습니다. 5.2부터는 {{proxyBeanMethods = false}} 옵션으로 *라이트 모드*를 사용할 수 있습니다.

{code:language=java|theme=Emacs}
// 기존 방식: CGLIB 프록시 생성 (기본값)
@Configuration
public class FullModeConfig {

    @Bean
    public DataSource dataSource() {
        return new HikariDataSource();
    }

    @Bean
    public JdbcTemplate jdbcTemplate() {
        // dataSource() 메서드를 직접 호출해도 싱글톤이 보장됨 (프록시 덕분)
        return new JdbcTemplate(dataSource());
    }
}

// 라이트 모드: CGLIB 프록시를 생성하지 않음 → 더 빠른 시작, 적은 메모리
@Configuration(proxyBeanMethods = false)
public class LiteModeConfig {

    @Bean
    public DataSource dataSource() {
        return new HikariDataSource();
    }

    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        // 라이트 모드에서는 메서드 직접 호출 대신 파라미터 주입을 사용해야 함
        return new JdbcTemplate(dataSource);
    }
}
{code}

*라이트 모드의 장점:*

* CGLIB 프록시를 생성하지 않아 *애플리케이션 시작 시간이 단축*됨
* *메모리 사용량 감소*
* GraalVM 네이티브 이미지 빌드에 유리

*주의사항:*

* \{\{@Bean\}\} 메서드를 직접 호출하면 매번 새 인스턴스가 생성되므로, 반드시 *파라미터 주입* 방식을 사용해야 합니다.

----

h3. 4. WebMvc.fn - 서블릿 기반 함수형 엔드포인트

기존에 WebFlux에서만 사용할 수 있던 함수형 엔드포인트 방식을 *서블릿(Spring MVC)* 환경에서도 사용할 수 있게 되었습니다. 어노테이션 없이 코드로 직접 라우팅을 정의합니다.

{code:language=java|theme=Emacs}
@Configuration(proxyBeanMethods = false)
public class RouterConfig {

    @Bean
    public RouterFunction<ServerResponse> userRoutes(UserHandler handler) {
        // 함수형 스타일로 HTTP 경로와 핸들러를 연결
        return RouterFunctions.route()
            .GET("/users/{id}", handler::getUser)
            .GET("/users", handler::listUsers)
            .POST("/users", handler::createUser)
            .build();
    }
}

@Component
public class UserHandler {

    private final UserService userService;

    public UserHandler(UserService userService) {
        this.userService = userService;
    }

    // ServerRequest를 받아 ServerResponse를 반환하는 함수형 핸들러
    public ServerResponse getUser(ServerRequest request) {
        Long id = Long.parseLong(request.pathVariable("id"));
        User user = userService.findById(id);
        return ServerResponse.ok().body(user);
    }

    public ServerResponse listUsers(ServerRequest request) {
        List<User> users = userService.findAll();
        return ServerResponse.ok().body(users);
    }

    public ServerResponse createUser(ServerRequest request) throws ServletException, IOException {
        User user = request.body(User.class);
        User saved = userService.save(user);
        return ServerResponse.status(HttpStatus.CREATED).body(saved);
    }
}
{code}

----

h3. 5. ReactiveTransactionManager

리액티브 환경에서 트랜잭션을 관리하기 위한 새로운 SPI(Service Provider Interface)입니다. 기존 {{PlatformTransactionManager}}의 리액티브 버전으로, R2DBC나 MongoDB Reactive 등에서 활용됩니다.

{code:language=java|theme=Emacs}
// 리액티브 트랜잭션 매니저 사용 예시
@Service
public class OrderService {

    private final TransactionalOperator transactionalOperator;

    public OrderService(ReactiveTransactionManager transactionManager) {
        // TransactionalOperator: 리액티브 트랜잭션을 프로그래밍 방식으로 관리
        this.transactionalOperator = TransactionalOperator.create(transactionManager);
    }

    public Mono<Order> createOrder(Order order) {
        return orderRepository.save(order)
            .as(transactionalOperator::transactional);  // 트랜잭션 적용
    }
}
{code}

----

h3. 6. MergedAnnotations API

Spring 내부의 어노테이션 검색 및 처리 엔진이 완전히 재작성되었습니다. {{MergedAnnotations}} API를 통해 메타 어노테이션(어노테이션 위에 붙은 어노테이션)을 더 빠르고 정확하게 탐색할 수 있습니다. 이 변경은 주로 프레임워크 내부 개선이지만, 커스텀 어노테이션을 만드는 개발자에게도 유용합니다.

----

h2. 새로운 기능

|| 기능 || 설명 ||
| *RSocket 메시징* | {{spring\-messaging}} 모듈에서 RSocket 프로토콜 지원 |
| *Kotlin 코루틴* | WebFlux에서 {{suspend}} 함수와 {{Flow}} 타입 사용 가능 |
| *WebMvc.fn* | 서블릿 환경에서의 함수형 엔드포인트 |
| *ReactiveTransactionManager* | 리액티브 트랜잭션 관리 인터페이스 |
| *MergedAnnotations API* | 어노테이션 탐색 엔진 재작성 |
| *{{@EventListener}} 비동기 지원 개선* | 리액티브 타입 반환을 지원하는 이벤트 리스너 |
| *{{ApplicationContext}} 초기화 개선* | 함수형 빈 등록 방식 강화 |

----

h2. 개선사항

|| 영역 || 내용 ||
| 요청 매핑 | 핸들러 검색 속도 개선 |
| HTTP 헤더 | 파싱 결과 캐싱 적용 |
| {{@Configuration}} | 라이트 모드로 CGLIB 프록시 생략 가능 |
| 테스트 | {{@TestConstructor}} 생성자 자동 주입 |

----

h2. 폐기(Deprecated) 및 제거(Removed) 항목

h3. 폐기된 항목

|| 항목 || 설명 || 대안 ||
| {{MediaType.APPLICATION\_JSON\_UTF8}} | JSON의 기본 인코딩이 UTF-8이므로 별도 지정 불필요 | {{MediaType.APPLICATION\_JSON}} 사용 |
| {{MediaType.APPLICATION\_PROBLEM\_JSON\_UTF8}} | 위와 동일한 이유 | {{MediaType.APPLICATION\_PROBLEM\_JSON}} 사용 |
| *Mock JNDI* | {{SimpleNamingContextBuilder}} 등 Mock JNDI 관련 클래스 | 직접 목(mock) 설정 또는 임베디드 데이터소스 사용 |
| *접미사 패턴 매칭(Suffix Pattern Matching)* | {{/users.\*}}와 같은 확장자 기반 매칭 | {{Accept}} 헤더 또는 쿼리 파라미터를 통한 콘텐츠 협상 사용 |

{quote}
*참고:* 접미사 패턴 매칭은 보안 취약점(RFD 공격 등)의 원인이 될 수 있어 폐기되었습니다.
{quote}

----

h2. 호환성

h3. 최소 요구사항

{code:language=text|title=mermaid|collapse=true|theme=Emacs}
graph LR
    A[Spring Framework 5.2] --> B[Java 8+]
    A --> C[Java 11 지원]
    A --> D[Jackson 2.9.7+]
    A --> E[Kotlin 1.3]
    A --> F[JUnit Jupiter 5.5.2]
    A --> G[Servlet 3.1+ / 4.0]
{code}

|| 항목 || 버전 ||
| *Java* | 8 이상 (Java 11 공식 지원) |
| *Jackson* | 2.9.7 이상 |
| *Kotlin* | 1.3 |
| *JUnit* | JUnit Jupiter 5.5.2 |
| *Servlet* | 3.1 이상 (Servlet 4.0 권장) |
| *Spring Boot* | 2.2.x |

----

h2. 참고 자료

* [Spring Framework 5.2 What's New (GitHub Wiki)|https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-5.x#whats-new-in-version-52]
* [Spring Framework 5.2 릴리즈 블로그|https://spring.io/blog/2019/09/30/spring-framework-5-2-goes-ga]
